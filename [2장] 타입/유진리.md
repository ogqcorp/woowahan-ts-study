# 2.1 타입이란

## 2.1.1. 자료형으로서의 타입

컴퓨터의 메모리 공간은 한정적이기 때문에 값의 크기를 명시하면 컴퓨터가 값을 제대로 해석해 효율적이고 안전하게 저장할 수 있다.

```javascript
const foo: number = 10;
```

<i>
ex. 메모리에 숫자 타입이 명시되어있다면 자바스크립트 엔진은 이 변수를 숫자로 인식하여 해당 크기만큼 메모리를 할당하고 값을 읽어온다 (8바이트)
</i>

<br/>

변수에 저장할 수 있는 값의 종류는 언어마다 다른데, 최신 ECMAScript 표준을 따르는 자바스크립트는 7가지 데이터타입(자료형)을 정의한다.

- undefined
- null
- Boolean
- String
- Symbol
- Numeric (Number와 BigInt)
- Object

<br/>

데이터 타입은 컴파일러에 값의 형태를 알려주는 분류 체계이다.
메모리 관점에서의 데이터 타입은 프로그래밍 언어에서 일반적으로 타입으로 부르는 개념과 같다.

<br/>

## 2.1.2 집합으로서의 타입

타입은 <strong>값이 가질 수 있는 유효한 범위의 집합</strong> 을 말한다.<br/>
타입 시스템은 코드에서 사용하는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지한다.

```javascript
function double(n: number) {
  return n * 2;
}

double(2); // 4
double("z"); // 🚨 Error: Argument of type 'string' is not assignable to parameter of type 'number'.(2345)
```

ex.
double("z")는 string 타입의 인자를 전달하므로 에러가 발생한다. <br/>
이는 타입이 집합의 경계처럼 동작하여 함수의 인자로 들어갈 수 있는 값을 number타입의 집합으로 제한하기 때문이다.<br/>
double(2)는 number 타입의 인자를 전달하므로 문제 없이 컴파일된다.

<br/>

## 2.1.3 정적 타입과 동적 타입

타입을 결정하는 시점에 따라 정적 타입과 동적 타입으로 분류할 수 있다.

- 정적 타입:

  - 모든 변수의 타입이 **\*컴파일 타임** 에 결정된다.
  - 컴파일 타임에 에러 발견 가능하여 프로그램의 안정성이 보장된다.

- 동적 타입:
  - 변수 타입이 **\*런타임** 에 결정된다.
  - 프로그램 실행시에 에러가 발견되므로, 코드 작성 과정이 편하고 자유롭다. (But 언제 오류가 생길지 모르는 불안정성)

<br/>

```javascript
function multiplyByThree(number) {
  return number * 3;
}

multiplyByThree(10); // 30
multiplyByThree("f"); // NaN
```

<br/>

## 2.1.4 강타입과 약타입

개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것을 **암묵적 타입 변환**이라고 한다.

암묵적 타입 변환 여부에 따라 타입 시스템을 **강타입**과 **약타입**으로 분류할 수 있다.

- 약타입
  - 서로 다른 타입을 갖는 값끼리 연산할 때는 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출한다.
  - C++, Java, Javascript
- 강타입
  - 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생한다.
  - Python, Ruby, Typescript

<br/>

```js
// 자바스크립트 - 약타입 언어

console.log("2" - 1); // 1
```

약타입 언어 - 예기치 못한 오류를 발생시킬 가능성이 있으므로, 런타임에서 발생할 수 있는 에러를 예측하고 방지하는 코드 작성 필요

```typescript
// 타입스크립트 - 강타입

console.log("2" - 1); // "2" error
// type error
// The left-hand side of an arithmetic operation must be of type ‘any’, ‘number’, ‘bigint’ or an enum type.
```

<br/>

타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합을 **타입 시스템** 이라고 하는데, 크게 두 가지로 구분한다.

- **명시적 타입 시스템** : 개발자가 직접 타입을 명시해줘야 한다.
- **자동 타입 추론 시스템** : 컴파일러가 자동으로 타입을 추론한다.

타입스크립트는 이 두 가지 방식을 모두 사용할 수 있고, 이를 통해 코드의 안정성과 가독성을 높일 수 있다.

<br/>

## 2.1.5 컴파일 방식

타입스크립트는 자바스크립트의 타입 에러를 컴파일 타임에 미리 잡아내기 위해 만들어진 것이다.
따라서 타입스크립트를 컴파일하면, 타입 정보가 모두 제거된 순수 자바스크립트 코드만 남는다.

<br/>
<br/>
<br/>

# 2.2 타입스크립트의 타입 시스템

## 2.2.1 타입 애너테이션 방식

타입 애너테이션이란 변수나 상수 혹은 함수의 인자와 변환 값에 타입을 명시적으로 선언해주는 문법이다.

타입스크립트의 타입 선언 방식은 변수 이름 뒤에 `: type` 구문을 붙여주는 것이다.

```typescript
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

<br/>

## 2.2.2 구조적 타이핑 ⭐️

타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다. 이를 **명목적으로 구체화한 타입 시스템** 이라고 부르기도 한다.

```typescript
class Animal {
    String name;
    int age;
}
```

타입스크립트는 명목적 타입 언어와 달리 _타입을 구조로 구분한다._ 이를 **구조적 타이핑** 이라 한다.
<br/>

```typescript
interface Developer {
  faceValue: number;
}

interface BankNote {
  faceValue: number;
}

let developer: Developer = { faceValue: 52 };
let bankNote: BankNote = { faceValue: 10000 };

developer = bankNote; // OK
bankNote = developer; // OK
```

<br/>

## 2.2.3 구조적 서브타이핑 ⭐️

타입스크립트의 **구조적 서브타이핑**은 객체가 가진 속성(프로퍼티)을 바탕으로 타입을 구분하는 방식이다. 이름이 다른 객체라도 가진 속성이 동일하다면 서로 호환 가능한 동일한 타입으로 여긴다.

```typescript
interface Pet {
  name: string;
}
interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

pet = cat; // OK
```

<br/>

```typescript
interface Pet {
  name: string;
}
let cat = { name: "Zag", age: 2 };

function greet(pet: Pet) {
  console.log("Hello" + pet.name);
}

great(cat); // OK

// cat객체는 Pet 인터페이스의 name 속성을 가지고 있으므로, name 속성에 접근 가능
```

<br/>

타입스크립트의 서브타이핑, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 하고있다.

```typescript
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`);
}

const developer = new Developer("zig", 20, 7);

greet(developer); // Hello, I'm zig
```

`Developer` 클래스가 `Person` 클래스를 상속받지 않아도 `Person`이 갖고 있는 속성을 가지고 있기 때문에 `greet()` 함수에 `Developer` 객체를 인자로 전달할 수 있다.

서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다. 타입 A가 타입 B의 서브타입이라면, A 타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다. 즉 타입이 계층 구조로부터 자유롭다.

<br/>
